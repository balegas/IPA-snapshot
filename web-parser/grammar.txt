V3


start
  = ({ops = []; invs = [];}) 
    (("INV" _* "=" _* inv:bin_or_sing_formula _*  {invs.push(inv)}) delim _*)* 
    ((op:operation _* {ops.push(op)}) delim _*)* 
  
  {return {"INV" : invs , "OPS" : ops}} 


bin_or_sing_formula
 = left:formula operator:operator right:bin_or_sing_formula 

 {return { "type" : operator, "left": left, "right": right}}
 
 / formula

formula
 = not 

 / arithmetic

 / quantified_formula                        
 
 / pred

arithmetic
 = left:pred _* op:arith_operator _* right:term 

 {return {"type": op, "left": left, "right": right}}

not 
 = "NOT" _* "(" _* formula:formula _* ")" _*    
 
 {return {"type" : "NOT", "formula" : formula}}
 
quantified_formula
 = "forall" _* vars:var_list _* ":" _* "(" _* formula:bin_or_sing_formula _* ")"

 {return {"type" : "forall", "vars" : vars, "formula" : formula}}

 / "exists" var_list "in" type ":" _* "(" _* formula _* ")" 

 {return {"type" : "exist", "vars" : vars, "formula" : formula}}

pred
  = pred_name:($(validupper validchar*))  _* "(" _* args:term_list _* ")" 

  {return {"type": "predicate", "predicate" : {"name" : pred_name, args : args}}}

operation
 = op_name:$validchar+ _* _* "(" _* args:term_list _* ")" _* ":=" effects:effects _* 

 {return {op_name, args, effects}}

effects 
 = head:effect "and" tail:effects 

 {return [head].concat(tail);}

 / _* effect:effect _*

 {return [effect]}


effect
 = _* formula:pred _* type:assign_oper _* value:const _* 

 {return {type, formula, value}}

 / _* "filter" _* arg:typed_var _* "(" _* expression:effect _* ")"

 {return {"filter": arg, expression}}

assign_oper
 = "="
 / "+"
 / "-"
 
term 
 = const
 / fun
 / typed_var
 / var
/* / wildcard*/


term_list
 = head:term _* "," _* tail:term_list 
 
 {return [head].concat(tail)}

 / head:term 

 {return [head]}

const
 = value:("true" / "false")

 {return {"type": "const", "value": {value, "type": "bool"}}}

 / value:integer

 {return {"type": "const", "value": {value, "type": "int"}}}

var 
 = var_name:$validchar+

 {return {"type": "variable", "value": {var_name, "type":"_"}}}

typed_var 
 = var_name:$validchar+":"type:$validchar+ 

 {return {"type": "variable", "value": {var_name, type}}}

var_list
 = var_name:$validchar+ _* "in" _* type:type _* "," _* tail:var_list 

 {return [{var_name, type}].concat(tail)}

 / var_name:$validchar+ _* "in" _* type:type 

 {return [{var_name, type}]}

type
 = type:$validupper+ 

 {return type}

fun
 = "_" fun_name:$validchar+ _* "(" args:term_list ")" 

 {return {"type": "function", "value" : {fun_name, args}}}

wildcard
 = var_name:"*"":"type:$validchar+ 

 {return {term_type: "wildcard", "value": {var_name, type}}}


_
  = [ \t\n\r]+

delim
  = ";"

validchar
 = [a-zA-Z0-9-_]

validupper
 = [A-Z]

operator
 = _* OP:("or" / "and" / "=>") _* {return OP}

arith_operator
 = _* OP:(">=" / "<=" / ">" / "<") _* {return OP}

integer "integer"
  = digits:[0-9]+ { return parseInt(digits.join(""), 10); }



Tournament spec;


INV = forall p in P, t in T : (Enrolled(p, t) => Tournament(t) and Player(p));
INV = forall p in P, t in T : (Leader(p, t)  => Enrolled(p, t) and Tournament(t));
INV = forall t in T : (Active(t)  => NrPlayers(t) >= 1 and NrLeaders(t) == 1);
INV = forall p in P, q in P, t in T : (InMatch(p, q, t)  => Active(t) and Participant(p, t) and Participant(q, t));

INV = forall p in P : (PBudget(p) >= 0);
INV = forall t in T : (NrPlayers(t) <= Capacity);
INV = forall t in T : (Active(t)  => NrPlayers(t) >= 1 and NrLeaders(t) == 1);

INV = forall p in P, t in T : ( Active(t) and Enrolled(p,t) ) => Participant(p, t);

enroll(p:P,t:T) := Enrolled(p, t) = true and Participant(p ,t) = false and PBudget(p) - 1 and NrPlayers(t) + 1;
disenroll(p:P,t:T) := Enrolled(p, t) = false and Participant(p ,t) = false and NrPlayers(t) - 1;
add_player(p:P) := Player(p) = true;
rem_player(p:P) := Player(p) = false;
add_Tournament(t:T) := Tournament(t) = true;
rem_Tournament(t:T) := Tournament(t) = false; 


INV = forall p in P, t in T : (Enrolled(p, t) => Tournament(t) and Player(p));
INV = forall p in P, t in T : (Leader(p, t)  => Enrolled(p, t) and Tournament(t));
INV = forall t in T : (Active(t)  => NrPlayers(t) >= 1 and NrLeaders(t) == 1);
INV = forall p in P, q in P, t in T : (InMatch(p, q, t)  => Active(t) and Participant(p, t) and Participant(q, t));

INV = forall p in P : (PBudget(p) >= 0);
INV = forall t in T : (NrPlayers(t) <= Capacity);
INV = forall t in T : (Active(t)  => NrPlayers(t) >= 1 and NrLeaders(t) == 1);

INV = forall p in P, t in T : ( Active(t) and Enrolled(p,t) => Participant(p, t));

enroll(p:P,t:T) := Enrolled(p, t) = true and Participant(p ,t) = false and PBudget(p) - 1 and NrPlayers(t) + 1;
disenroll(p:P,t:T) := Enrolled(p, t) = false and Participant(p ,t) = false and NrPlayers(t) - 1;
add_player(p:P) := Player(p) = true;
rem_player(p:P) := Player(p) = false;
add_Tournament(t:T) := Tournament(t) = true;
rem_Tournament(t:T) := Tournament(t) = false; 
setLeader(p:P, t:T) := NrLeaders(t) + 1 and Leader(p, t) = true;
addFunds(p:P) := PBudget(p) + 1;
doMatch(p:P, q:P, t:T) :=  InMatch(p, q, t) = true;
beginTournament(p:P, t:T) := Active(t) = true and Participant(p:P, t) = true;
endTournament(t:T) := Active(t) = false and Participant(_1:P, t) = false and InMatch(_2:P, _3:P, t) = false;	
